<?php

declare(strict_types=1);
/**
 * AUTO-GENERATED by WPKernel CLI.
 * Edits between WPK:BEGIN AUTO and WPK:END AUTO will be overwritten.
 * Source: wpk.config.ts â†’ capability-map ([fallback])
 */
namespace Test\Namespace\Generated\Capability;

use WP_Error;
use WP_REST_Request;
// WPK:BEGIN AUTO
final class Capability
{
    public static function capability_map(): array
    {
        return [];
    }
    public static function fallback(): array
    {
        return ['appliesTo' => 'resource', 'capability' => 'manage_options'];
    }
    /** Create a permission callback closure for a capability. */
    public static function callback(string $capability_key): callable
    {
        return static function (WP_REST_Request $request) use ($capability_key) {
            return self::enforce($capability_key, $request);
        };
    }
    private static function resolve_capability(string $capability, array $fallback): string
    {
        $fallback_capability = isset($fallback['capability']) && is_string($fallback['capability']) ? $fallback['capability'] : 'manage_options';
        if ($capability === $fallback_capability) {
            return $capability;
        }
        if (function_exists('get_role')) {
            $role = get_role('administrator');
            if ($role && $role->has_cap($capability)) {
                return $capability;
            }
        }
        return $fallback_capability;
    }
    /**
     * Evaluate a capability against the current user.
     * @return bool|WP_Error
     */
    public static function enforce(string $capability_key, WP_REST_Request $request)
    {
        $definition = self::get_definition($capability_key);
        $fallback = self::fallback();
        $capability = isset($definition['capability']) ? $definition['capability'] : $fallback['capability'];
        $runtime_capability = self::resolve_capability($capability, $fallback);
        $scope = isset($definition['appliesTo']) ? $definition['appliesTo'] : $fallback['appliesTo'];
        $allowed = current_user_can($runtime_capability);
        if ('object' === $scope) {
            $binding = self::get_binding($definition);
            if ($binding === null) {
                $binding = 'id';
            }
            $object_id = $request->get_param($binding);
            if ($object_id === null) {
                return self::create_error('wpk_capability_object_missing', sprintf('Object identifier parameter "%s" missing for capability "%s".', $binding, $capability_key));
            }
            $allowed = current_user_can($runtime_capability, $object_id);
        }
        if ($allowed) {
            return true;
        }
        return self::create_error('wpk_capability_denied', 'You are not allowed to perform this action.', ['capability' => $capability_key, 'capability' => $capability]);
    }
    private static function get_definition(string $capability_key): array
    {
        $map = self::capability_map();
        if (isset($map[$capability_key])) {
            return $map[$capability_key];
        }
        return self::fallback();
    }
    private static function get_binding(array $definition): ?string
    {
        $binding = isset($definition['binding']) ? $definition['binding'] : null;
        if (is_string($binding) && $binding !== '') {
            return $binding;
        }
        return null;
    }
    private static function create_error(string $code, string $message, array $context = []): WP_Error
    {
        $payload = array_merge(['status' => 403], $context);
        return new WP_Error($code, $message, $payload);
    }
}
// WPK:END AUTO
