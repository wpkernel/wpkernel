// Jest Snapshot v1, https://jestjs.io/docs/snapshot-testing

exports[`createPhpBuilder integration emits PHP + AST artefacts via the PHP driver without touching legacy printers: base-controller.php 1`] = `
"<?php

declare(strict_types=1);
/**
 * AUTO-GENERATED by WPKernel CLI.
 * Edits between WPK:BEGIN AUTO and WPK:END AUTO will be overwritten.
 * Source: wpk.config.ts → resources (namespace: demo-plugin)
 */
namespace Demo\\Plugin\\Generated\\Rest;

// WPK:BEGIN AUTO
abstract class BaseController
{
    public function get_namespace(): string
    {
        return 'demo-plugin';
    }
}
// WPK:END AUTO
"
`;

exports[`createPhpBuilder integration emits PHP + AST artefacts via the PHP driver without touching legacy printers: books-controller.php 1`] = `
"<?php

declare(strict_types=1);
/**
 * AUTO-GENERATED by WPKernel CLI.
 * Edits between WPK:BEGIN AUTO and WPK:END AUTO will be overwritten.
 * Source: wpk.config.ts → resources.books
 * Schema: book (manual)
 * Route: [GET] /wpk/v1/books
 * Route: [GET] /wpk/v1/books/:slug
 * Route: [POST] /wpk/v1/books
 * Route: [PUT] /wpk/v1/books/:slug
 * Route: [DELETE] /wpk/v1/books/:slug
 */
namespace Demo\\Plugin\\Generated\\Rest;

use WP_Error;
use WP_Post;
use WP_Query;
use WP_REST_Request;
use function is_wp_error;
// WPK:BEGIN AUTO
class BooksController extends BaseController
{
    public function get_resource_name(): string
    {
        return 'books';
    }
    public function get_schema_key(): string
    {
        return 'book';
    }
    public function get_rest_args(): array
    {
        return [];
    }
    /**
     * Register REST routes for this controller.
     * Capability enforcement happens inside each handler via Capability::enforce,
     * so permission_callback is intentionally __return_true here.
     */
    public function register_routes(): void
    {
        // permission_callback is __return_true; capabilities enforced inside handlers.
        register_rest_route('wpk/v1', '/books', [['methods' => 'GET', 'callback' => [$this, 'getWpkV1Books'], 'permission_callback' => '__return_true'], ['methods' => 'POST', 'callback' => [$this, 'postWpkV1Books'], 'permission_callback' => '__return_true']]);
        // permission_callback is __return_true; capabilities enforced inside handlers.
        register_rest_route('wpk/v1', '/books/(?P<slug>[\\\\\\\\w-]+)', [['methods' => 'GET', 'callback' => [$this, 'getWpkV1BooksSlug'], 'permission_callback' => '__return_true'], ['methods' => 'PUT', 'callback' => [$this, 'putWpkV1BooksSlug'], 'permission_callback' => '__return_true'], ['methods' => 'DELETE', 'callback' => [$this, 'deleteWpkV1BooksSlug'], 'permission_callback' => '__return_true']]);
    }
    /**
     * Handle [GET] /wpk/v1/books.
     * @wp-kernel route-kind list
     */
    public function getWpkV1Books(WP_REST_Request $request)
    {
        $post_type = $this->getBooksPostType();
        $per_page = (int) $request->get_param('per_page');
        if ($per_page <= 0) {
            $per_page = 10;
        }
        if ($per_page > 100) {
            $per_page = 100;
        }
        
        $statuses = $this->getBooksStatuses();
        
        $query_args = ['post_type' => $post_type, 'post_status' => $statuses, 'fields' => 'ids', 'paged' => max(1, (int) $request->get_param('page')), 'posts_per_page' => $per_page];
        
        $meta_query = [];
        $statusMeta = $request->get_param('status');
        if ($statusMeta !== null) {
            $statusMeta = match (is_scalar($statusMeta)) {
                true => trim((string) $statusMeta),
                default => null,
            };
            if ($statusMeta !== null && $statusMeta !== '') {
                $meta_query[] = ['key' => 'status', 'compare' => '=', 'value' => $statusMeta];
            }
        }
        $tagsMeta = $request->get_param('tags');
        if ($tagsMeta !== null) {
            if (!is_array($tagsMeta)) {
                $tagsMeta = [$tagsMeta];
            }
            $tagsMeta = array_values((array) $tagsMeta);
            $tagsMeta = array_filter($tagsMeta, static fn($value) => match (trim((string) $value)) {
                '' => false,
                default => true,
            });
            if (count($tagsMeta) > 0) {
                $meta_query[] = ['key' => 'tags', 'compare' => 'IN', 'value' => $tagsMeta];
            }
        }
        if (count($meta_query) > 0) {
            $query_args['meta_query'] = $meta_query;
        }
        
        $tax_query = [];
        $genresTerms = $request->get_param('genres');
        if ($genresTerms !== null) {
            $genresTerms = array_filter(array_map(static fn($value) => (int) $value, (array) $genresTerms), static fn($value) => $value > 0);
            if (count($genresTerms) > 0) {
                $tax_query[] = ['taxonomy' => 'book_genre', 'field' => 'term_id', 'terms' => $genresTerms];
            }
        }
        if (count($tax_query) > 0) {
            $query_args['tax_query'] = $tax_query;
        }
        
        $query = new WP_Query($query_args);
        
        $items = [];
        
        foreach ($query->posts as $post_id) {
            $post = get_post($post_id);
            if (!$post instanceof WP_Post) {
                continue;
            }
            $items[] = $this->prepareBooksResponse($post, $request);
        }
        
        return ['items' => $items, 'total' => (int) $query->found_posts, 'pages' => (int) $query->max_num_pages];
    }
    /**
     * Handle [GET] /wpk/v1/books/:slug.
     * @wp-kernel route-kind get
     */
    public function getWpkV1BooksSlug(WP_REST_Request $request)
    {
        $slug = $request->get_param('slug');
        
        if (!is_string($slug) || '' === trim($slug)) {
            return new WP_Error('wpk_books_missing_identifier', 'Missing identifier for Books.', ['status' => 400]);
        }
        $slug = trim((string) $slug);
        
        $post = $this->resolveBooksPost($slug);
        if (!$post instanceof WP_Post) {
            return new WP_Error('wpk_books_not_found', 'Books not found.', ['status' => 404]);
        }
        
        return $this->prepareBooksResponse($post, $request);
    }
    /**
     * Handle [POST] /wpk/v1/books.
     * @wp-kernel route-kind create
     * @wp-kernel resource.wpPost.mutation create
     */
    public function postWpkV1Books(WP_REST_Request $request)
    {
        $post_type = $this->getBooksPostType();
        $post_data = ['post_type' => $post_type];
        // @wp-kernel resource.wpPost.mutation status-validation
        // @wp-kernel mutation:status normalise
        $status = $request->get_param('status');
        $post_data['post_status'] = $this->normaliseBooksStatus($status);
        $post_id = wp_insert_post($post_data, true);
        if (is_wp_error($post_id)) {
            return $post_id;
        }
        if (0 === $post_id) {
            return new WP_Error('wpk_books_create_failed', 'Unable to create Books.', ['status' => 500]);
        }
        // @wp-kernel resource.wpPost.mutation sync-meta
        // @wp-kernel mutation:meta update
        $this->syncBooksMeta($post_id, $request);
        // @wp-kernel resource.wpPost.mutation sync-taxonomies
        // @wp-kernel mutation:taxonomies update
        $taxonomy_result = $this->syncBooksTaxonomies($post_id, $request);
        if (is_wp_error($taxonomy_result)) {
            return $taxonomy_result;
        }
        // @wp-kernel resource.wpPost.mutation cache-priming
        // @wp-kernel mutation:cache prime
        // @wp-kernel cache:wp-post prime
        $post = get_post($post_id);
        if (!$post instanceof WP_Post) {
            return new WP_Error('wpk_books_load_failed', 'Unable to load created Books.', ['status' => 500]);
        }
        return $this->prepareBooksResponse($post, $request);
    }
    /**
     * Handle [PUT] /wpk/v1/books/:slug.
     * @wp-kernel route-kind update
     * @wp-kernel resource.wpPost.mutation update
     */
    public function putWpkV1BooksSlug(WP_REST_Request $request)
    {
        $slug = $request->get_param('slug');
        
        $slug = $request->get_param('slug');
        if (!is_string($slug) || '' === trim($slug)) {
            return new WP_Error('wpk_books_missing_identifier', 'Missing identifier for Books.', ['status' => 400]);
        }
        $slug = trim((string) $slug);
        $post = $this->resolveBooksPost($slug);
        if (!$post instanceof WP_Post) {
            return new WP_Error('wpk_books_not_found', 'Books not found.', ['status' => 404]);
        }
        $post_data = ['ID' => $post->ID, 'post_type' => $this->getBooksPostType()];
        // @wp-kernel resource.wpPost.mutation status-validation
        // @wp-kernel mutation:status normalise
        $status = $request->get_param('status');
        if (null !== $status) {
            $post_data['post_status'] = $this->normaliseBooksStatus($status);
        }
        $result = wp_update_post($post_data, true);
        if (is_wp_error($result)) {
            return $result;
        }
        if (0 === $result) {
            return new WP_Error('wpk_books_update_failed', 'Unable to update Books.', ['status' => 500]);
        }
        // @wp-kernel resource.wpPost.mutation sync-meta
        // @wp-kernel mutation:meta update
        $this->syncBooksMeta($post->ID, $request);
        // @wp-kernel resource.wpPost.mutation sync-taxonomies
        // @wp-kernel mutation:taxonomies update
        $taxonomy_result = $this->syncBooksTaxonomies($post->ID, $request);
        if (is_wp_error($taxonomy_result)) {
            return $taxonomy_result;
        }
        // @wp-kernel resource.wpPost.mutation cache-priming
        // @wp-kernel mutation:cache prime
        // @wp-kernel cache:wp-post prime
        $updated = get_post($post->ID);
        if (!$updated instanceof WP_Post) {
            return new WP_Error('wpk_books_load_failed', 'Unable to load updated Books.', ['status' => 500]);
        }
        return $this->prepareBooksResponse($updated, $request);
    }
    /**
     * Handle [DELETE] /wpk/v1/books/:slug.
     * @wp-kernel route-kind remove
     * @wp-kernel resource.wpPost.mutation delete
     */
    public function deleteWpkV1BooksSlug(WP_REST_Request $request)
    {
        $slug = $request->get_param('slug');
        
        $slug = $request->get_param('slug');
        if (!is_string($slug) || '' === trim($slug)) {
            return new WP_Error('wpk_books_missing_identifier', 'Missing identifier for Books.', ['status' => 400]);
        }
        $slug = trim((string) $slug);
        $post = $this->resolveBooksPost($slug);
        if (!$post instanceof WP_Post) {
            return new WP_Error('wpk_books_not_found', 'Books not found.', ['status' => 404]);
        }
        $previous = $this->prepareBooksResponse($post, $request);
        $deleted = wp_delete_post($post->ID, true);
        if (false === $deleted) {
            return new WP_Error('wpk_books_delete_failed', 'Unable to delete Books.', ['status' => 500]);
        }
        return ['deleted' => true, 'id' => (int) $post->ID, 'previous' => $previous];
    }
    protected function getBooksPostType(): string
    {
        return 'book';
    }
    protected function getBooksStatuses(): array
    {
        return ['draft', 'publish'];
    }
    protected function normaliseBooksStatus($status): string
    {
        $allowed = $this->getBooksStatuses();
        $candidate = is_string($status) ? strtolower($status) : '';
        foreach ($allowed as $value) {
            if ($candidate === strtolower($value)) {
                return $value;
            }
        }
        $fallback = 'draft';
        if (!in_array('draft', $allowed, true)) {
            if (!empty($allowed)) {
                $fallback = $allowed[0];
            }
        }
        return $fallback;
    }
    protected function resolveBooksPost($slug)
    {
        $post_type = $this->getBooksPostType();
        $slug = is_string($slug) ? trim($slug) : '';
        if ($slug === '') {
            return null;
        }
        $posts = get_posts(['post_type' => $post_type, 'posts_per_page' => 1, 'fields' => 'all', 'meta_key' => 'uuid', 'meta_value' => $slug]);
        if (!empty($posts)) {
            return $posts[0];
        }
        $post = get_page_by_path($slug, 'OBJECT', $post_type);
        if ($post instanceof WP_Post) {
            return $post;
        }
        return null;
    }
    private function syncBooksMeta(int $post_id, WP_REST_Request $request): void
    {
        $statusMeta = rest_sanitize_value_from_request('status', $request);
        if (null !== $statusMeta) {
            $statusMeta = is_string($statusMeta) ? $statusMeta : (string) $statusMeta;
            update_post_meta($post_id, 'status', $statusMeta);
        }
        $tagsMeta = rest_sanitize_value_from_request('tags', $request);
        if (null !== $tagsMeta) {
            $tagsMeta = array_values((array) $tagsMeta);
            delete_post_meta($post_id, 'tags');
            foreach ((array) $tagsMeta as $value) {
                add_post_meta($post_id, 'tags', $value);
            }
        }
    }
    function syncBooksTaxonomies(int $post_id, WP_REST_Request $request)
    {
        $result = true;
        $genresTerms = rest_sanitize_value_from_request('genres', $request);
        if (null !== $genresTerms) {
            if (!is_array($genresTerms)) {
                $genresTerms = [$genresTerms];
            }
            $genresTerms = array_filter(array_map('intval', $genresTerms));
            $result = wp_set_object_terms($post_id, $genresTerms, 'book_genre', false);
            if (is_wp_error($result)) {
                return $result;
            }
        }
        return $result;
    }
    function prepareBooksResponse(WP_Post $post, WP_REST_Request $request): array
    {
        $data = ['id' => (int) $post->ID, 'slug' => (string) $post->post_name, 'status' => (string) $post->post_status];
        $data['title'] = (string) $post->post_title;
        $statusMeta = get_post_meta($post->ID, 'status', true);
        $data['status'] = $statusMeta;
        $tagsMeta = get_post_meta($post->ID, 'tags', false);
        $data['tags'] = $tagsMeta;
        $genresTerms = wp_get_object_terms($post->ID, 'book_genre', ['fields' => 'ids']);
        if (is_wp_error($genresTerms)) {
            $genresTerms = [];
        }
        $genresTerms = array_map('intval', $genresTerms);
        $data['genres'] = $genresTerms;
        return $data;
    }
}
// WPK:END AUTO
"
`;

exports[`createPhpBuilder integration emits PHP + AST artefacts via the PHP driver without touching legacy printers: capability-helper.php 1`] = `
"<?php

declare(strict_types=1);
/**
 * AUTO-GENERATED by WPKernel CLI.
 * Edits between WPK:BEGIN AUTO and WPK:END AUTO will be overwritten.
 * Source: wpk.config.ts → capability-map ([fallback])
 */
namespace Demo\\Plugin\\Generated\\Capability;

use WP_Error;
use WP_REST_Request;
// WPK:BEGIN AUTO
final class Capability
{
    public static function capability_map(): array
    {
        return [];
    }
    public static function fallback(): array
    {
        return ['appliesTo' => 'resource', 'capability' => 'manage_options'];
    }
    /** Create a permission callback closure for a capability. */
    public static function callback(string $capability_key): callable
    {
        return static function (WP_REST_Request $request) use ($capability_key) {
            return self::enforce($capability_key, $request);
        };
    }
    private static function resolve_capability(string $capability, array $fallback): string
    {
        $fallback_capability = isset($fallback['capability']) && is_string($fallback['capability']) ? $fallback['capability'] : 'manage_options';
        if ($capability === $fallback_capability) {
            return $capability;
        }
        if (function_exists('get_role')) {
            $role = get_role('administrator');
            if ($role && $role->has_cap($capability)) {
                return $capability;
            }
        }
        return $fallback_capability;
    }
    /**
     * Evaluate a capability against the current user.
     * @return bool|WP_Error
     */
    public static function enforce(string $capability_key, WP_REST_Request $request)
    {
        $definition = self::get_definition($capability_key);
        $fallback = self::fallback();
        $capability = isset($definition['capability']) ? $definition['capability'] : $fallback['capability'];
        $runtime_capability = self::resolve_capability($capability, $fallback);
        $scope = isset($definition['appliesTo']) ? $definition['appliesTo'] : $fallback['appliesTo'];
        $allowed = current_user_can($runtime_capability);
        if ('object' === $scope) {
            $binding = self::get_binding($definition);
            if ($binding === null) {
                $binding = 'id';
            }
            $object_id = $request->get_param($binding);
            if ($object_id === null) {
                return self::create_error('wpk_capability_object_missing', sprintf('Object identifier parameter "%s" missing for capability "%s".', $binding, $capability_key));
            }
            $allowed = current_user_can($runtime_capability, $object_id);
        }
        if ($allowed) {
            return true;
        }
        return self::create_error('wpk_capability_denied', 'You are not allowed to perform this action.', ['capability' => $capability_key, 'capability' => $capability]);
    }
    private static function get_definition(string $capability_key): array
    {
        $map = self::capability_map();
        if (isset($map[$capability_key])) {
            return $map[$capability_key];
        }
        return self::fallback();
    }
    private static function get_binding(array $definition): ?string
    {
        $binding = isset($definition['binding']) ? $definition['binding'] : null;
        if (is_string($binding) && $binding !== '') {
            return $binding;
        }
        return null;
    }
    private static function create_error(string $code, string $message, array $context = []): WP_Error
    {
        $payload = array_merge(['status' => 403], $context);
        return new WP_Error($code, $message, $payload);
    }
}
// WPK:END AUTO
"
`;

exports[`createPhpBuilder integration emits PHP + AST artefacts via the PHP driver without touching legacy printers: demo-option-controller.php 1`] = `
"<?php

declare(strict_types=1);
/**
 * AUTO-GENERATED by WPKernel CLI.
 * Edits between WPK:BEGIN AUTO and WPK:END AUTO will be overwritten.
 * Source: wpk.config.ts → resources.demoOption
 * Schema: demoOption (manual)
 * Route: [GET] /wpk/v1/demo-option
 * Route: [PUT] /wpk/v1/demo-option
 */
namespace Demo\\Plugin\\Generated\\Rest;

use WP_Error;
use WP_REST_Request;
use function is_wp_error;
// WPK:BEGIN AUTO
class DemoOptionController extends BaseController
{
    public function get_resource_name(): string
    {
        return 'demoOption';
    }
    public function get_schema_key(): string
    {
        return 'demoOption';
    }
    public function get_rest_args(): array
    {
        return [];
    }
    /**
     * Register REST routes for this controller.
     * Capability enforcement happens inside each handler via Capability::enforce,
     * so permission_callback is intentionally __return_true here.
     */
    public function register_routes(): void
    {
        // permission_callback is __return_true; capabilities enforced inside handlers.
        register_rest_route('wpk/v1', '/demo-option', [['methods' => 'GET', 'callback' => [$this, 'getWpkV1DemoOption'], 'permission_callback' => '__return_true'], ['methods' => 'PUT', 'callback' => [$this, 'putWpkV1DemoOption'], 'permission_callback' => '__return_true']]);
    }
    /**
     * Handle [GET] /wpk/v1/demo-option.
     * @wp-kernel route-kind custom
     */
    public function getWpkV1DemoOption(WP_REST_Request $request)
    {
        $option_name = $this->getDemoOptionOptionName();
        $value = get_option($option_name);
        
        return ['option' => $option_name, 'value' => $value];
    }
    /**
     * Handle [PUT] /wpk/v1/demo-option.
     * @wp-kernel route-kind custom
     */
    public function putWpkV1DemoOption(WP_REST_Request $request)
    {
        $option_name = $this->getDemoOptionOptionName();
        $previous = get_option($option_name);
        $value = $request->get_param('value');
        $autoload = $this->normaliseDemoOptionAutoload($request->get_param('autoload'));
        
        $updated = null !== $autoload ? update_option($option_name, $value, $autoload) : update_option($option_name, $value);
        
        $value_after = get_option($option_name);
        
        return ['option' => $option_name, 'updated' => (bool) $updated, 'value' => $value_after, 'previous' => $previous];
    }
    private function getDemoOptionOptionName(): string
    {
        return 'demo_option';
    }
    private function normaliseDemoOptionAutoload($value): ?string
    {
        if (null === $value) {
            return null;
        }
        if (is_bool($value)) {
            if ($value) {
                return 'yes';
            }
            return 'no';
        }
        if (is_numeric($value)) {
            if ((int) $value === 1) {
                return 'yes';
            }
            return 'no';
        }
        if (!is_string($value)) {
            return null;
        }
        $normalised = strtolower(trim((string) $value));
        if (in_array($normalised, ['1', 'true', 'yes'], true)) {
            return 'yes';
        }
        if (in_array($normalised, ['0', 'false', 'no'], true)) {
            return 'no';
        }
        return null;
    }
}
// WPK:END AUTO
"
`;

exports[`createPhpBuilder integration emits PHP + AST artefacts via the PHP driver without touching legacy printers: job-cache-controller.php 1`] = `
"<?php

declare(strict_types=1);
/**
 * AUTO-GENERATED by WPKernel CLI.
 * Edits between WPK:BEGIN AUTO and WPK:END AUTO will be overwritten.
 * Source: wpk.config.ts → resources.jobCache
 * Schema: jobCache (manual)
 * Route: [GET] /wpk/v1/job-cache
 * Route: [PUT] /wpk/v1/job-cache
 * Route: [DELETE] /wpk/v1/job-cache
 */
namespace Demo\\Plugin\\Generated\\Rest;

use WP_Error;
use WP_REST_Request;
use function is_wp_error;
// WPK:BEGIN AUTO
class JobCacheController extends BaseController
{
    public function get_resource_name(): string
    {
        return 'jobCache';
    }
    public function get_schema_key(): string
    {
        return 'jobCache';
    }
    public function get_rest_args(): array
    {
        return [];
    }
    /**
     * Register REST routes for this controller.
     * Capability enforcement happens inside each handler via Capability::enforce,
     * so permission_callback is intentionally __return_true here.
     */
    public function register_routes(): void
    {
        // permission_callback is __return_true; capabilities enforced inside handlers.
        register_rest_route('wpk/v1', '/job-cache', [['methods' => 'GET', 'callback' => [$this, 'getWpkV1JobCache'], 'permission_callback' => '__return_true'], ['methods' => 'PUT', 'callback' => [$this, 'putWpkV1JobCache'], 'permission_callback' => '__return_true'], ['methods' => 'DELETE', 'callback' => [$this, 'deleteWpkV1JobCache'], 'permission_callback' => '__return_true']]);
    }
    /**
     * Handle [GET] /wpk/v1/job-cache.
     * @wp-kernel route-kind custom
     */
    public function getWpkV1JobCache(WP_REST_Request $request)
    {
        $key = $this->getJobCacheTransientKey();
        $value = get_transient($key);
        
        return ['key' => $key, 'value' => $value];
    }
    /**
     * Handle [PUT] /wpk/v1/job-cache.
     * @wp-kernel route-kind custom
     */
    public function putWpkV1JobCache(WP_REST_Request $request)
    {
        $key = $this->getJobCacheTransientKey();
        $previous = get_transient($key);
        $value = $request->get_param('value');
        $expiration = $this->normaliseJobCacheExpiration($request->get_param('expiration'));
        
        $stored = set_transient($key, $value, $expiration);
        $current = get_transient($key);
        
        return ['key' => $key, 'stored' => (bool) $stored, 'value' => $current, 'previous' => $previous, 'expiration' => $expiration];
    }
    /**
     * Handle [DELETE] /wpk/v1/job-cache.
     * @wp-kernel route-kind custom
     */
    public function deleteWpkV1JobCache(WP_REST_Request $request)
    {
        $key = $this->getJobCacheTransientKey();
        $previous = get_transient($key);
        
        $deleted = delete_transient($key);
        
        return ['key' => $key, 'deleted' => (bool) $deleted, 'previous' => $previous];
    }
    private function getJobCacheTransientKey(...$segments): string
    {
        $parts = ['demo_plugin_job_cache'];
        foreach ($segments as $segment) {
            if (null !== $segment) {
                $normalised = trim((string) $segment);
                if (!('' === $normalised)) {
                    $parts[] = $normalised;
                }
            }
        }
        return implode('_', $parts);
    }
    private function normaliseJobCacheExpiration($value): int
    {
        if (null === $value) {
            return 0;
        }
        if (is_int($value)) {
            return max(0, $value);
        }
        if (is_numeric($value)) {
            return max(0, (int) $value);
        }
        if (!is_string($value)) {
            return 0;
        }
        $sanitised = trim((string) $value);
        if ('' === $sanitised) {
            return 0;
        }
        if (is_numeric($sanitised)) {
            return max(0, (int) $sanitised);
        }
        return 0;
    }
}
// WPK:END AUTO
"
`;
