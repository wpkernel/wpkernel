import {
	type PhpStmt,
	buildDeclare,
	buildDeclareItem,
	buildScalarInt,
	buildBooleanNot,
	buildFuncCall,
	buildName,
	buildArg,
	buildClass,
	buildIdentifier,
	type PhpName,
	buildNamespace,
	buildStmtNop,
	buildDocComment,
	type PhpExpr,
	buildNode,
	buildScalarString,
	buildBinaryOperation,
	type PhpAttributes,
	type buildPhpPrettyPrinter,
} from '@wpkernel/php-json-ast';
import type { IRv1, IRResource } from '../ir';
import type { BuildShimOptions, PlanInstruction } from './types';
import path from 'path';
import type { BuilderApplyOptions } from '../runtime/types';
import { toPascalCase } from '../utils';
import { resolvePlanPaths } from './plan.paths';

export function buildShimProgram(options: BuildShimOptions) {
	const { ir, resource, className, generatedClassFqn, requirePath } = options;

	const statements: PhpStmt[] = [];
	statements.push(
		buildDeclare([buildDeclareItem('strict_types', buildScalarInt(1))])
	);

	const namespaceStatements: PhpStmt[] = [];
	namespaceStatements.push(buildAutoGuardComment());
	namespaceStatements.push(
		buildIfStatement(
			buildBooleanNot(buildClassExistsCall(generatedClassFqn)),
			[
				buildExpressionStatement(
					buildFuncCall(buildName(['require_once']), [
						buildArg(buildRequireExpression(requirePath)),
					])
				),
			]
		)
	);

	namespaceStatements.push(
		buildClass(
			buildIdentifier(className),
			{
				extends: buildName(
					generatedClassFqn
						.split('\\')
						.filter((segment) => segment.length > 0)
				) as PhpName,
				stmts: [],
			},
			buildClassAttributes(ir, resource)
		)
	);

	const namespaceNode = buildNamespace(
		buildName(
			[ir.php.namespace, 'Rest'].join('\\').split('\\').filter(Boolean)
		) as PhpName,
		namespaceStatements
	);
	statements.push(namespaceNode);

	return statements;
}
function buildAutoGuardComment(): PhpStmt {
	return buildStmtNop({
		comments: [
			buildDocComment([
				'WPKernel extension shim.',
				'Edits to this file will be preserved during apply operations.',
			]),
		],
	});
}
function buildClassExistsCall(fqn: string): PhpExpr {
	return buildFuncCall(buildName(['class_exists']), [
		buildArg(
			buildNode('Expr_ClassConstFetch', {
				class: buildName(
					fqn.split('\\').filter((segment) => segment.length > 0)
				),
				name: buildIdentifier('class'),
			})
		),
	]);
}
function buildRequireExpression(relative: string): PhpExpr {
	const dirConst = buildNode('Scalar_MagicConst_Dir', {}) as PhpExpr;
	const suffix = buildScalarString(
		relative.startsWith('/') ? relative : `/${relative}`
	);
	return buildBinaryOperation('Concat', dirConst, suffix);
}
function buildClassAttributes(ir: IRv1, resource: IRResource): PhpAttributes {
	return {
		comments: [
			buildDocComment([
				'AUTO-GENERATED by WPKernel CLI.',
				`Source: ${ir.meta.origin} â†’ resources.${resource.name}`,
				`Schema: ${resource.schemaKey} (${resource.schemaProvenance})`,
			]),
		],
	} satisfies PhpAttributes;
}
function buildIfStatement(cond: PhpExpr, stmts: PhpStmt[]): PhpStmt {
	return buildNode('Stmt_If', { cond, stmts, elseifs: [], else: null });
}
function buildExpressionStatement(expr: PhpExpr): PhpStmt {
	return buildNode('Stmt_Expression', { expr });
}
export function normaliseAutoloadPath(value: string): string {
	if (!value) {
		return '';
	}

	const trimmed = value.replace(/\\/g, '/');
	const normalised = trimmed.endsWith('/') ? trimmed.slice(0, -1) : trimmed;
	return normalised.startsWith('./') ? normalised.slice(2) : normalised;
}
export async function collectResourceInstructions({
	options,
	prettyPrinter,
}: {
	readonly options: BuilderApplyOptions;
	readonly prettyPrinter: ReturnType<typeof buildPhpPrettyPrinter>;
}): Promise<PlanInstruction[]> {
	const resourceInstructions: PlanInstruction[] = [];
	const paths = resolvePlanPaths(options);

	for (const resource of options.input.ir?.resources ?? []) {
		const instruction = await emitShim({
			options,
			paths,
			prettyPrinter,
			resource,
		});
		if (instruction) {
			resourceInstructions.push(instruction);
		}
	}

	return resourceInstructions;
}

async function emitShim({
	options,
	paths,
	prettyPrinter,
	resource,
}: {
	readonly options: BuilderApplyOptions;
	readonly paths: ReturnType<typeof resolvePlanPaths>;
	readonly prettyPrinter: ReturnType<typeof buildPhpPrettyPrinter>;
	readonly resource: IRResource;
}): Promise<PlanInstruction | null> {
	const { input, context, output, reporter } = options;
	const { ir } = input;

	if (!ir) {
		reporter.warn(
			'createApplyPlanBuilder: IR artifact missing, skipping shim emission.',
			{ resource: resource.name }
		);
		return null;
	}

	const className = `${toPascalCase(resource.name)}Controller`;
	const generatedNamespaceRoot = `${ir.php.namespace}\\Generated`;
	const generatedClassFqn = `${generatedNamespaceRoot}\\Rest\\${className}`;

	const autoloadRoot = normaliseAutoloadPath(ir.php.autoload);
	const targetFile = path.posix.join(
		autoloadRoot,
		'Rest',
		`${className}.php`
	);
	const incomingPath = path.posix.join(paths.planIncoming, targetFile);
	const basePath = path.posix.join(paths.planBase, targetFile);

	const requireRelative = path.posix.relative(
		path.posix.dirname(targetFile),
		path.posix.join(paths.phpGenerated, 'Rest', `${className}.php`)
	);

	const program = buildShimProgram({
		ir,
		resource,
		className,
		generatedClassFqn,
		requirePath: formatRequirePath(requireRelative, paths.phpGenerated),
	});

	const { code } = await prettyPrinter.prettyPrint({
		filePath: context.workspace.resolve(incomingPath),
		program,
	});

	await context.workspace.write(incomingPath, code, { ensureDir: true });
	output.queueWrite({ file: incomingPath, contents: code });

	const existingBase = await context.workspace.readText(basePath);
	if (existingBase === null) {
		await context.workspace.write(basePath, code, { ensureDir: true });
		output.queueWrite({ file: basePath, contents: code });
	}

	reporter.debug('createApplyPlanBuilder: queued shim instruction.', {
		resource: resource.name,
		file: targetFile,
	});

	return {
		action: 'write',
		file: targetFile,
		base: basePath,
		incoming: incomingPath,
		description: `Update ${resource.name} controller shim`,
	} satisfies PlanInstruction;
}

export function formatRequirePath(relative: string, phpRoot: string): string {
	if (!relative) {
		return `/${phpRoot}`;
	}

	const prefixed = relative.startsWith('.') ? relative : `./${relative}`;
	return prefixed.startsWith('/') ? prefixed : `/${prefixed}`;
}
